#!/usr/bin/env python3
"""
Tkinter GUI for managing SQLite databases generated by the Autogen pipeline.

Features
--------
* Auto‑detect ``*.db`` files in a configurable directory (default: ``./Databases``)
* Enable WAL mode and a 30 s busy timeout for safe concurrent access
* List tables of the selected database
* View the first 100 rows of a table (configurable)
* Insert a new row via a simple JSON dialog
* Update or delete a selected row using a JSON “where” clause
* All operations use the standard library ``sqlite3`` module only

The UI is deliberately lightweight – it is intended for quick inspection and
lightweight edits while developing or debugging agents.  For heavy‑weight
analytics you would normally query the DB programmatically.

Usage
-----
```
python -m DatabaseFiles.gui_db_manager --db-dir path/to/Databases
```
"""

import argparse
import json
import os
import sqlite3
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from typing import Any, Dict, List, Optional

# ----------------------------------------------------------------------
# Helper: SQLite manager with WAL + busy timeout (mirrors db_manager_agent)
# ----------------------------------------------------------------------
def _apply_wal_and_timeout(conn: sqlite3.Connection) -> None:
    """Enable WAL mode and a 30 s busy timeout on *conn*."""
    try:
        conn.execute("PRAGMA journal_mode=WAL;")
        conn.execute("PRAGMA busy_timeout=30000;")
    except sqlite3.Error as e:
        # Non‑critical – continue
        print(f"[WARN] Could not set WAL/timeout: {e}")


def discover_databases(db_dir: str) -> List[str]:
    """Return absolute paths of all ``*.db`` files inside *db_dir*."""
    if not os.path.isdir(db_dir):
        return []
    return [
        os.path.abspath(os.path.join(db_dir, f))
        for f in os.listdir(db_dir)
        if f.lower().endswith(".db")
    ]


class SQLiteGUIManager:
    """Thin wrapper exposing the subset of SQLiteManager needed by the GUI."""
    def __init__(self, db_dir: str = "Databases"):
        self.db_dir = db_dir
        self.conn: Optional[sqlite3.Connection] = None
        self.db_path: Optional[str] = None

    def list_databases(self) -> List[str]:
        return discover_databases(self.db_dir)

    def connect(self, db_path: str) -> None:
        if self.conn:
            self.close()
        self.conn = sqlite3.connect(db_path, timeout=30.0)
        _apply_wal_and_timeout(self.conn)
        self.db_path = db_path

    def close(self) -> None:
        if self.conn:
            self.conn.close()
        self.conn = None
        self.db_path = None

    def _ensure_conn(self) -> sqlite3.Connection:
        if not self.conn:
            raise sqlite3.Error("No active connection")
        return self.conn

    def list_tables(self) -> List[str]:
        cur = self._ensure_conn().cursor()
        cur.execute(
            "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;"
        )
        return [row[0] for row in cur.fetchall()]

    def fetch(
        self,
        table: str,
        columns: str = "*",
        where: Optional[Dict[str, Any]] = None,
        order_by: Optional[str] = None,
        descending: bool = False,
        limit: Optional[int] = 100,
    ) -> List[Dict[str, Any]]:
        conn = self._ensure_conn()
        conn.row_factory = sqlite3.Row
        query = f"SELECT {columns} FROM {table}"
        params: List[Any] = []

        if where:
            clauses = [f"{col}=?" for col in where]
            query += " WHERE " + " AND ".join(clauses)
            params.extend(where.values())

        if order_by:
            query += f" ORDER BY {order_by} {'DESC' if descending else 'ASC'}"

        if limit is not None:
            query += f" LIMIT {limit}"

        cur = conn.cursor()
        cur.execute(query, tuple(params))
        rows = cur.fetchall()
        return [dict(r) for r in rows]

    def insert(self, table: str, data: Dict[str, Any]) -> int:
        conn = self._ensure_conn()
        cols = ", ".join(data.keys())
        placeholders = ", ".join("?" for _ in data)
        sql = f"INSERT INTO {table} ({cols}) VALUES ({placeholders})"
        cur = conn.cursor()
        cur.execute(sql, tuple(data.values()))
        conn.commit()
        return cur.lastrowid

    def update(
        self,
        table: str,
        data: Dict[str, Any],
        where: Dict[str, Any],
    ) -> int:
        conn = self._ensure_conn()
        set_clause = ", ".join(f"{k}=?" for k in data)
        where_clause = " AND ".join(f"{k}=?" for k in where)
        sql = f"UPDATE {table} SET {set_clause} WHERE {where_clause}"
        params = list(data.values()) + list(where.values())
        cur = conn.cursor()
        cur.execute(sql, tuple(params))
        conn.commit()
        return cur.rowcount

    def delete(self, table: str, where: Dict[str, Any]) -> int:
        conn = self._ensure_conn()
        where_clause = " AND ".join(f"{k}=?" for k in where)
        sql = f"DELETE FROM {table} WHERE {where_clause}"
        cur = conn.cursor()
        cur.execute(sql, tuple(where.values()))
        conn.commit()
        return cur.rowcount


# ----------------------------------------------------------------------
# GUI implementation
# ----------------------------------------------------------------------
class DBManagerApp(tk.Tk):
    def __init__(self, db_dir: str):
        super().__init__()
        self.title("SQLite Database Manager")
        self.geometry("1000x600")
        self.mgr = SQLiteGUIManager(db_dir)

        # ---- UI layout -------------------------------------------------
        self.columnconfigure(1, weight=1)
        self.rowconfigure(0, weight=1)

        # Left panel – database list
        db_frame = ttk.Frame(self)
        db_frame.grid(row=0, column=0, sticky="ns")
        ttk.Label(db_frame, text="Databases").pack(padx=5, pady=5)
        self.db_listbox = tk.Listbox(db_frame, height=20, width=40)
        self.db_listbox.pack(padx=5, pady=5, fill="y")
        self.db_listbox.bind("<<ListboxSelect>>", self.on_db_select)

        # Right panel – tables + rows
        right_frame = ttk.Frame(self)
        right_frame.grid(row=0, column=1, sticky="nsew")
        right_frame.columnconfigure(0, weight=1)
        right_frame.rowconfigure(2, weight=1)

        # Table list
        ttk.Label(right_frame, text="Tables").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        self.table_listbox = tk.Listbox(right_frame, height=6)
        self.table_listbox.grid(row=1, column=0, sticky="ew", padx=5)
        self.table_listbox.bind("<<ListboxSelect>>", self.on_table_select)

        # Row view (Treeview)
        self.tree = ttk.Treeview(right_frame, show="headings")
        self.tree.grid(row=2, column=0, sticky="nsew", padx=5, pady=5)
        self.tree["displaycolumns"] = ()

        # Action buttons
        btn_frame = ttk.Frame(right_frame)
        btn_frame.grid(row=3, column=0, sticky="ew", pady=5)
        ttk.Button(btn_frame, text="Refresh DB List", command=self.refresh_dbs).pack(
            side="left", padx=2
        )
        ttk.Button(btn_frame, text="Refresh Tables", command=self.refresh_tables).pack(
            side="left", padx=2
        )
        ttk.Button(btn_frame, text="Refresh Rows", command=self.refresh_rows).pack(
            side="left", padx=2
        )
        ttk.Button(btn_frame, text="Insert Row", command=self.insert_row).pack(
            side="left", padx=2
        )
        ttk.Button(btn_frame, text="Update Row", command=self.update_row).pack(
            side="left", padx=2
        )
        ttk.Button(btn_frame, text="Delete Row", command=self.delete_row).pack(
            side="left", padx=2
        )

        # Populate initial DB list
        self.refresh_dbs()

    # ------------------------------------------------------------------
    # UI callbacks
    # ------------------------------------------------------------------
    def refresh_dbs(self):
        self.db_listbox.delete(0, tk.END)
        for db_path in self.mgr.list_databases():
            self.db_listbox.insert(tk.END, db_path)

    def on_db_select(self, event: tk.Event):
        selection = self.db_listbox.curselection()
        if not selection:
            return
        db_path = self.db_listbox.get(selection[0])
        try:
            self.mgr.connect(db_path)
        except sqlite3.Error as e:
            messagebox.showerror("Connection error", str(e))
            return
        self.refresh_tables()

    def refresh_tables(self):
        self.table_listbox.delete(0, tk.END)
        try:
            tables = self.mgr.list_tables()
        except sqlite3.Error as e:
            messagebox.showerror("Error", str(e))
            return
        for t in tables:
            self.table_listbox.insert(tk.END, t)

    def on_table_select(self, event: tk.Event):
        self.refresh_rows()

    def refresh_rows(self):
        self.tree.delete(*self.tree.get_children())
        selection = self.table_listbox.curselection()
        if not selection:
            return
        table = self.table_listbox.get(selection[0])
        try:
            rows = self.mgr.fetch(table)
        except sqlite3.Error as e:
            messagebox.showerror("Fetch error", str(e))
            return
        if not rows:
            return
        # Configure columns
        columns = list(rows[0].keys())
        self.tree["columns"] = columns
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=100, anchor="center")
        for row in rows:
            values = [row[col] for col in columns]
            self.tree.insert("", tk.END, values=values)

    # ------------------------------------------------------------------
    # CRUD helpers (JSON dialogs)
    # ------------------------------------------------------------------
    def _prompt_json(self, title: str, example: str = "{}") -> Optional[Dict]:
        txt = simpledialog.askstring(title, f"Enter JSON dict (e.g. {example}):")
        if txt is None:
            return None
        try:
            data = json.loads(txt)
            if not isinstance(data, dict):
                raise ValueError("JSON must represent an object")
            return data
        except json.JSONDecodeError as e:
            messagebox.showerror("Invalid JSON", f"{e}")
            return None

    def insert_row(self):
        selection = self.table_listbox.curselection()
        if not selection:
            messagebox.showwarning("No table", "Select a table first.")
            return
        table = self.table_listbox.get(selection[0])
        data = self._prompt_json("Insert into " + table, '{"col1": "value"}')
        if data is None:
            return
        try:
            rowid = self.mgr.insert(table, data)
            messagebox.showinfo("Success", f"Inserted rowid {rowid}")
            self.refresh_rows()
        except sqlite3.Error as e:
            messagebox.showerror("Insert error", str(e))

    def update_row(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("No row", "Select a row to update.")
            return
        selection = self.table_listbox.curselection()
        if not selection:
            messagebox.showwarning("No table", "Select a table first.")
            return
        table = self.table_listbox.get(selection[0])
        # Build a WHERE clause from the selected row (all columns)
        values = self.tree.item(sel[0])["values"]
        cols = self.tree["columns"]
        where = dict(zip(cols, values))

        new_data = self._prompt_json(
            f"Update row in {table}", '{"col_to_change": "new_value"}'
        )
        if new_data is None:
            return
        try:
            cnt = self.mgr.update(table, new_data, where)
            messagebox.showinfo("Success", f"Updated {cnt} row(s)")
            self.refresh_rows()
        except sqlite3.Error as e:
            messagebox.showerror("Update error", str(e))

    def delete_row(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("No row", "Select a row to delete.")
            return
        selection = self.table_listbox.curselection()
        if not selection:
            messagebox.showwarning("No table", "Select a table first.")
            return
        table = self.table_listbox.get(selection[0])
        values = self.tree.item(sel[0])["values"]
        cols = self.tree["columns"]
        where = dict(zip(cols, values))

        if not messagebox.askyesno(
            "Confirm Delete", f"Delete the selected row from {table}?"
        ):
            return
        try:
            cnt = self.mgr.delete(table, where)
            messagebox.showinfo("Success", f"Deleted {cnt} row(s)")
            self.refresh_rows()
        except sqlite3.Error as e:
            messagebox.showerror("Delete error", str(e))

    def on_closing(self):
        self.mgr.close()
        self.destroy()


def parse_args():
    parser = argparse.ArgumentParser(
        description="Tkinter GUI SQLite manager (Autogen‑compatible)"
    )
    parser.add_argument(
        "--db-dir",
        default="Databases",
        help="Directory containing *.db files (default: %(default)s)",
    )
    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()
    app = DBManagerApp(args.db_dir)
    app.protocol("WM_DELETE_WINDOW", app.on_closing)
    app.mainloop()
